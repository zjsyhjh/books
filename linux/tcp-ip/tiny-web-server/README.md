## TINY Web服务器

#### 1. TINY的main程序

`TINY`是一个迭代服务器，监听在命令行中传递来的端口上的连接请求。在通过调用`open_listenfd`函数打开一个监听套接字以后，`TINY`执行典型的无限服务器循环，不断地接受连接请求，执行事务，并关闭连接的它那一端

#### 2. doit函数

`doit`函数处理一个`HTTP`事务。首先，我们读和解析请求行（通过`rio_readlineb`函数读取请求行）。`TINY`只支持`GET`方法。如果客户端请求其他方法（比如`POST`），我们发送给它一个错误信息，并返回到主程序，主程序随后关闭连接并等待下一个连接请求。否则，我们读并且忽略任何请求报文头。然后，我们将`URI`解析为一个文件名和一个可能为空的`CGI`参数字符串，并且设置一个标志，表明请求的是静态内容还是动态内容。如果文件在磁盘上不存在，我们立即发送一个错误信息给客户端并返回。最后，如果请求的是静态内容，我们就验证该文件是一个普通文件，而我们是有读权限的。如果是，我们就向客户端提供静态内容，否则，如果是动态内容，就验证该文件是否是可执行文件，如果是，就提供动态内容

#### 3. clienterror函数

`TINY`缺乏一个实际服务器的许多错误处理特性。然而，它会检查一些明显的错误，并把它们报告给客户端。`clienterror`函数发送一个`HTTP`响应到客户端，在响应行中包含相应的状态码和状态消息，响应主体中包含一个`HTML`文件，向浏览器用户解释这个错误

`HTML`响应应该指明主体中内容的大小和类型。因此，我们选择创建`HTML`内容为一个字符串，这样一来我们可以简单地确定它的大小

#### 4. read_requesthdrs函数

`TINY`不使用请求报头中的任何信息。它仅仅调用`read_requesthdrs`函数来读取并忽略这些报头（终止请求报头的空文本行是由回车和换行符对组成的）

#### 5. parse_uri函数

`TINY`假设静态内容的主目录就是它的当前目录，而可执行文件的主目录就是`./cgi-bin`。任何包含字符串`cgi-bin`的`URI`都会被认为表示的是对动态内容的请求。默认的文件名是`./home.html`

`parse_uri`函数实现了这些策略。它将`URI`解析为一个文件名和一个可选的`CGI`参数字符串。如果请求的是静态内容，我们将清除`CGI` 参数字符串，然后将`URI`转换为一个`Linux`相对路径名（例如`./index.html`）。如果`URI`是用`/`结尾的，我们将把默认的文件名加在后面。另一方面，如果请求的是动态内容，我们将会抽取出所有的`CGI`参数，并将`URI`剩下的部分转换为一个`Linux`相对文件名

#### 6. serve_static函数

`TINY`提供了五种常见类型的静态内容：`HTML`文件、无格式的文本文件、以及编码为`GIF`、`PNG`和`JPG`格式的图片

`serve_static`函数发送一个`HTTP`响应，其主体包含一个本地文件的内容。首先，我们通过检查文件名的后缀来判断文件类型，并且发送响应行和响应报头给客户端（注意用一个空行终止报头）。接着，我们将被请求文件的内容复制到已连接描述符`fd`来发送响应主体（通过只读的方式打开`filename`，并获得它的描述符，利用`Linux mmap`函数将文件`srcfd`的前`filesize`个字节映射到一个从地址`srcp`开始的私有只读虚拟内存区域。一旦将文件映射到内存，就不再需要它的描述符了，所以我们关闭这个文件。`rio_writen`函数复制从`srcp`位置开始的`filesize`个字节到客户端的已连接描述符。最后，调用`munmap`函数释放映射的虚拟内存区域

#### 7. serve_dynamic函数

`TINY`通过派生一个子进程并在子进程的上下文中运行一个`CGI`程序，来提供各种类型的动态内容

`serve_dynamic`函数一开始就向客户端发送一个表明成功的响应行，同时还包括带有信息的`Server`报头。`CGI`程序负责发送响应的剩余部分。在发送了响应的第一部分后，我们会派生一个新的子进程。子进程用来自请求`URI`的`CGI`参数初始化`QUERY_STRING`环境变量（注意，一个真正的服务器还会在此处设置其他的CGI环境变量）。接下来，子进程重定向它的标准输出到已连接文件描述符，然后加载并运行`CGI`程序。因为`CGI`程序运行在子进程的上下文中，它能够访问所有在调用`execve`函数之前就存在的打开文件和环境变量。因此，`CGI`程序写到标准输出上的任何东西都将直接送到客户端进程，不会受到任何来自父进程的干涉。其间，父进程阻塞在对`wait`的调用中，等待当子进程终止的时候，回收操作系统分配给子进程的资源

#### 8. 运行TINY
在服务器端执行如下命令
```shell
make
./tiny <port>(例如: tiny 8000)
```
用浏览器访问`TINY`
```shell
static content: http://<host>:8000
dynamic content: http://<host>:8000/cgi-bin/cgi?2&3

```



[参考博客](http://www.cnblogs.com/wwwjieo0/p/3674018.html)

