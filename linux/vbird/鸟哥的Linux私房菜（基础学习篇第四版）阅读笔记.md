### 基础指令

- 相关目录操作
  - `.`：代表此层目录
  - `..`：代表上一层目录
  - `-`：代表上一个工作目录
  - `~`：代表当前用户所在的主目录
  - `cd`：变化目录
  - `pwd`：显示当前路径


- `ls`：查看目录和文件，选项参数如下

  - `-a`：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来
  - `-A`：全部的文件，连同隐藏文件，但不包括 `.` 与`..`这两个目录
  - `-d`：仅列出目录本身，而不是列出目录内的文件数据
  - `-l`：长数据串行出，包含文件的属性与权限等等数据
  - `-h`：将文件大小以人类较易读的方式（例如`GB`,`KB`等等）列出来
  - `-r`：将排序结果反向输出
  - `-R`：连同子目录内容一起列出来，该目录下的所有文件都会显示出来
  - `-S`：以文件大小大小排序，而不是用文件名排序
  - `-t`：依时间排序，而不是用文件名
  - `-f`：直接列出结果，而不进行排序 （`ls` 默认会以文件名排序）
  - `-i`：列出`inode`号码

- `mv`：移动目录和文件，选项参数如下

  - `-f`：`force`的缩写，若目标文件已经存在，则不会询问直接覆盖
  - `-i`：若目标文件已经存在，则会询问是否覆盖
  - `-u`：若目标文件已经存在并且源文件比目标文件新时，才会更新

- `rm`：删除目录和文件，选项参数如下

  - `-r`：递归删除
  - `-f`：强制删除，不会出现警告信息
  - `-i`：互动模式

- `mkdir`：创建目录

  - `-p`：允许创建中间目录

- `rmdir`：删除目录

- 改变文件属性与权限

  - `chgrp`：改变文件所属群组
  - `chown`：改变文件拥有者
  - `chmod`：改变文件权限

- `cat`：显示文件内容

  - `-b`：列出行号，仅针对非空白行做行号显示，空白行不标行号
  - `-n`：打印出行号，连同空白行也会有行号，与 -b 的选项不同

- `tac`：从最后一行开始显示文件内容

- `more`：一页页显示文件内容

  - 空格：向下翻一页
  - `enter`：向下翻一行

- `less`：与`more`类似，但比`more`更好用，支持向前翻页

  - 空格：向下翻一页
  - `[pagedown]`：向下翻一页
  - `[pageup]`：向上翻一页

- `head`：查看文件头几行

- `tail`：查看文件后几行

  - `-n`：代表显示的行数

- `touch`：新建文件

- `file`：查看文件类型

- `which`：在`PATH`路径下查找指定文件

- `whereis`：查找指定文件

- `locate`：搜索包含指定词的文件

- `find`：查找具体文件

  - `-name filename`：搜寻文件名称为 filename 的文件；
  - `-size [+-]SIZE`：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：
    - `c`: 代表 Byte
    - `k`: 代表 1024Bytes
    - 所以，要找比 50KB 还要大的文件，就是 `-size +50k`
  - `-type TYPE`：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。

- `cut`：用于选取文件中每一行的指定内容，选项参数如下

  - `-d`：后面接分隔字符。与 -f 一起使用；
  - `-f`：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；
  - `-c`：以字符 （characters） 的单位取出固定字符区间

- `grep`：过滤信息，选项参数

  - `-i`：忽略大小写的不同，所以大小写视为相同
  - `-n`：顺便输出行号
  - `-v`：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行

- `sort`：排序，选项参数如下

  - `-f`：忽略大小写的差异，例如 A 与 a 视为编码相同；
  - `-b`：忽略最前面的空白字符部分；
  - `-M`：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
  - `-n`：使用“纯数字”进行排序（默认是以文字体态来排序的）；
  - `-r`：反向排序；
  - `-u`：就是 uniq ，相同的数据中，仅出现一行代表；
  - `-t`：分隔符号，默认是用 [tab] 键来分隔；
  - `-k`：以那个区间 （field） 来进行排序的意思

- `wc`：用于统计字数

  - `-l`：仅列出行；
  - `-w`：仅列出多少字（英文单字）；
  - `-m` ：多少字符

- `uniq`：去重

  - `-i`：忽略大小写字符的不同；
  - `-c`：进行计数

- `tee`：可以将数据保存到文件的同时并且输出到屏幕

  - 如`history | tee history.log | less`：将`history`内容保存到文件的同时也输出到屏幕上

- `split`：用于将一个大文件，依据文件大小或行数来分区

  - `-b`：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；
  - `-l`：以行数来进行分区

- `xargs`：用于产生某个指令的参数

  -  `-n`：后面接次数，每次 command 指令执行时，要使用几个参数的意思

- `tar`：用于将多个目录或文件打包成一个文件，tar 并不会主动的产生创建的文件名喔！我们要自订啦！ 所以扩展名就显的很重要了！如果不加 `[-z|-j|-J]` 的话，文件名最好取为 `*.tar` 即可。如果是 `-j`选项，代表有 bzip2 的支持，因此文件名最好就取为 `*.tar.bz2`，因为 bzip2 会产生 `.bz2` 的扩展名之故！ 至于如果是加上了 `-z` 的 gzip 的支持，那文件名最好取为 `*.tar.gz`喔！

  另外值得一提的是，tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！ 如果仅是打包而已，就是 `tar -cv -f file.tar`而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如 `tar -jcv -f file.tar.bz2` 时，我们就称呼为 tarball，选项参数如下

  - `-c`：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）
  - `-t`：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；
  - `-x`：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。
  - `-z`：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz
  - `-j`：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2
  - `-J`：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中
  - `-v`：在压缩/解压缩的过程中，将正在处理的文件名显示出来！
  - `-C 目录`：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项

- `gzip`：压缩/解压缩工具，选项参数如下

  - `-c`：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；
  - `-d`：解压缩的参数；
  - `-t`：可以用来检验一个压缩文件的一致性～看看文件有无错误；
  - `-v`：可以显示出原文件/压缩文件的压缩比等信息；
  - `-n`：n 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好，默认是 -6

- `zcat/zmore/zless/zgrep`：`cat/more/less` 可以使用不同的方式来读取文件，而`zcat/zmore/zless`则对应于`cat/more/less`的方式来读取文件被压缩后的压缩文件

- `bzip2`：用于替代`gzip`来提供更佳的压缩比，选项参数如下

  - `-c`：将压缩的过程产生的数据输出到屏幕上！
  - `-d`：解压缩的参数
  - `-k`：保留原始文件，而不会删除原始的文件
  - `-z`：压缩的参数 （默认值，可以不加）
  - `-v`：可以显示出原文件/压缩文件的压缩比等信息
  - `-n`：与`gzip`同样的，都是在计算压缩比的参数， -9 最佳， -1 最快

- `bzcat/bzmore/bzless/bzgrep`：与`zcat/zmore/zless/zgrep`类似

### 用户管理

##### UID与GID

每个登陆的使用者至少都会取得两个 ID ，一个是使用者 ID （User ID ，简称 UID）、一个是群组 ID （Group ID ，简称 GID）

那么文件如何判别他的拥有者与群组呢？其实就是利用 UID 与 GID 啦！每一个文件都会有所谓的拥有者 ID 与拥有群组 ID ，当我们有要显示文件属性的需求时，系统会依据 /etc/passwd与 /etc/group 的内容， 找到 UID / GID 对应的帐号与群组名称再显示出来

`/etc/passwd`文件结构：每一行都有7个字段，使用`:`分隔

- 帐号名称： 用来提供给对数字不太敏感的人类使用来登陆系统的！需要用来对应 UID。例如 root 的 UID 对应
- 密码： 早期 Unix 系统的密码就是放在这字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成密码数据被窃取， 因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了。所以这里你会看到一个“ x ”
- UID：使用者识别码
  - 0：系统管理员
  - 1-999：系统账号
  - 1000-60000：可登陆账号
- GID： 这个与 /etc/group 有关！其实 /etc/group 的观念与 /etc/passwd 差不多，只是他是用来规范群组名称与 GID 的对应而已
- 使用者信息说明栏： 这个字段基本上并没有什么重要用途，只是用来解释这个帐号的意义而已
- 主文件夹： 这是使用者的主文件夹，以上面为例， root 的主文件夹在 /root ，所以当root 登陆之后，就会立刻跑到 /root 目录里
- Shell：当使用者登陆系统后就会取得一个 Shell 来与系统的核心沟通以进行使用者的操作任务

`/etc/group`文件结构：每一行有4个字段，使用`:`分隔，分别是

- 群组名称
- 群组密码
- GID
- 此群组支持的帐号名称

##### 账号管理

新增用户：`useradd [-u UID][-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 使用者帐号名`，选项参数如下

- `-u` ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个帐号；
- `-g`：后面接群组名称，该群组的 GID 会被放置到 /etc/passwd 的第四个字段内
- `-G` ：后面接的群组名称则是这个帐号还可以加入的群组。 这个选项与参数会修改 /etc/group 内的相关数据
- `-M` ：强制！不要创建使用者主文件夹！（系统帐号默认值）
- `-m` ：强制！要创建使用者主文件夹！（一般帐号默认值）
- `-c` ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设置的啦～
- `-d` ：指定某个目录成为主文件夹，而不要使用默认值。务必使用绝对路径！
- `-r` ：创建一个系统的帐号，这个帐号的 UID 会有限制 （参考 /etc/login.defs）
- `-s` ：后面接一个 shell ，若没有指定则默认是 /bin/bash 的啦～
- `-e` ：后面接一个日期，格式为“YYYY-MM-DD”此项目可写入 shadow 第八字段， 即帐号失效日的设置项目
- `-f` ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效，-1 为永远不失效（密码只会过期而强制于登陆时重新设置而已）

修改用户账号：`usermod [-cdegGlsuL] username`

- `-c` ：后面接帐号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些帐号的说明
- `-d` ：后面接帐号的主文件夹，即修改 /etc/passwd 的第六栏
- `-e` ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据
- `-f` ：后面接天数，为 shadow 的第七字段
- `-g` ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段
- `-G` ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group
- `-a` ：与 -G 合用，可“增加次要群组的支持”而非“设置”
- `-l` ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏
- `-s` ：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等
- `-u` ：后面接 UID 数字啦！即 /etc/passwd 第三栏的数据
- `-L` ：暂时将使用者的密码冻结，让他无法登陆。其实仅改 /etc/shadow 的密码栏

删除用户：`userdel [-r] username`

- `-r`：连同使用者的主文件夹也一起删除

查询用户相关的UID/GID等信息：`id [usrname]`

新增群组：`groupadd [-g gid][-r] 群组名称`

- `-g` ：后面接某个特定的 GID ，用来直接给予某个 GID
- `-r` ：创建系统群组

修改群组：`groupmod [-g gid] [-n group_name] 群组名`

- `-g` ：修改既有的 GID 数字
- `-n` ：修改既有的群组名称

 删除群组：`groupdel [groupname]`

### 文件系统

文件系统的特性：我们都知道磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件
系统。 为什么需要进行“格式化”呢？这是因为每种操作系统所设置的文件属性/权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的“文件系统格式（filesystem）”

传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列（software raid）， 这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM, RAID）！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区

文件系统的运作涉及到三个关键概念：

- `superblock`：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等
- `inode`：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block号码
- `block`：实际记录文件的内容，若文件太大时，会占用多个 block

查看文件系统信息

- `df`：显示文件系统各区的使用情况
- `dumpe2fs [-bh] 设备文件名`：查询Ext家族superblock信息

文件系统的简单操作

- `ln`：硬链接（两个文件名同时指向同一个inode,这个inode指向实际数据）
- `ln -s`：软链接（两个文件名指向不同inode,原文件的文件名指向的inode指向实际数据，软链接文件的文件名指向的inode不指向实际数据，而指向原文件的文件名所在的block）

`/dev/sd[a-p][1-128]`：为实体磁盘的磁盘文件名

`/dev/vd[a-d][1-128]`：为虚拟磁盘的磁盘文件名

磁盘相关操作

-  `fdisk`：管理磁盘分区表
- `mkfs`：格式化
- `fsck`：检验文件系统
- `mount/umount`：挂载/卸载

###  系统监视

- 了解系统基本信息
  - `uname`：显示系统信息
  - `hostname`：显示主机名
  - `last`：显示最近用户的登录信息
  - `lastlog`：显示每一个用户的登录信息
  - `free`：显示内存使用情况
  - `vmstat`：详细显示内存使用情况
  - `top`：系统监视器
- 进程
  - `ps`
    - `-a`：显示与终端无关的所有进程
    - `-A`：列出所有的进程
    - `-e`：列出所有的进程
    - `-u`：列出有效用户的相关进程
    - `-x`：列出完成信息
    - `-l`：以一种详细的方式显示进程信息
    - `-f`：以一种完整的方式显示进程信息
  - `pstree`：以树状的方式表示进程的父子关系
  - `kill`：`kill [-signal] PID`向进程传送一个特定的讯号,默认为15（终结）
    - `-l`：列出所有可以由`kill`传递的信号
    - `kill -9 PID`来强制结束进程
  - `jobs`：列出系统当前所有的后台进程
  - `fg`：将后台进程移到前台
  - `bg`：激活后台暂停的进程
- 常用的系统日志
  - 查看核心启动日志：`cat /var/log/dmsg`或`dmsg`
  - 系统报错日志：`/var/log/messages`
  - 安全信息，系统登陆于网络连接的信息：`/var/log/secure`
  - 登陆记录：`/var/log/wtmp`

### Vim

##### 一般模式下的可用按键

- 光标移动
  - `h 或 向左方向键（←）`：光标向左移动一个字符
  - `j 或 向下方向键（↓）`：光标向下移动一个字符
  - `k 或 向上方向键（↑）`：光标向上移动一个字符
  - `l 或 向右方向键（→）`：光标向右移动一个字符
  -  如果想要进行多次移动的话，例如向下移动 30 列，可以使用 `30j` 或 `30↓` 的组合按键
  - `[Ctrl] + [f]`：屏幕“向下”移动一页，相当于`[Page Down]`按键
  - `[Ctrl] + [b]`：屏幕“向上”移动一页，相当于 `[Page Up] `按键
  - `[Ctrl] + [d]`：屏幕“向下”移动半页
  - `[Ctrl] + [u]`：屏幕“向上”移动半页
  - `+`：光标移动到非空白字符的下一列
  - `-`：光标移动到非空白字符的上一列
  - `n<space>`：那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。
  - `0 或功能键[Home]`：这是数字“ 0 ”：移动到这一列的最前面字符处
  - `$ 或功能键[End]`：移动到这一列的最后面字符处
  - `H`：光标移动到这个屏幕的最上方那一列的第一个字符
  - `M`：光标移动到这个屏幕的中央那一列的第一个字符
  - `L`：光标移动到这个屏幕的最下方那一列的第一个字符
  - `G`：移动到这个文件的最后一列
  - `nG`：n 为数字。移动到这个文件的第 n 列，例如 20G 则会移动到这个文件的第 20 列
  - `gg`：移动到这个文件的第一列，相当于 1G
  - `n<Enter>`：n 为数字，光标向下移动 n 行
- 复制粘贴
  - `x, X`：在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键）
  - `nx`：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”
  - `dd`：删除光标所在的那一整列（常用）
  - `ndd`：n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用）
  - `d1G`：删除光标所在到第一列的所有数据
  - `dG`：删除光标所在到最后一列的所有数据
  - `d$`：删除光标所在处，到该列的最后一个字符
  - `d0`：那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符
  - `yy`：复制光标所在的那一列（常用）
  - `nyy`：n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用）
  - `y1G`：复制光标所在列到第一列的所有数据
  - `yG`：复制光标所在列到最后一列的所有数据
  - `y0`：复制光标所在的那个字符到该列行首的所有数据
  - `y$`：复制光标所在的那个字符到该列行尾的所有数据
  - `p, P`：p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用）
  - `J`：将光标所在列与下一列的数据结合成同一列
  - `c`：重复删除多个数据，例如向下删除 10 列，[ 10cj ]
  - `u`：复原前一个动作。（常用）
  - `[Ctrl]+r`：重做上一个动作。（常用）这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！
  - `.`：不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用）
- 搜寻替换
  - `/word`：向光标之下寻找一个名称为 word 的字串
  - `?word`：向光标之上寻找一个字串名称为 word 的字串
  - `n`：这个 n 是英文按键，代表“重复前一个搜寻的动作”，与`/word`和`?word`配合使用
  - `N`：这个 N 是英文按键，与 n 刚好相反，为“反向”进行前一个搜寻动作，与`/word`和`?word`配合使用
  - `:n1,n2s/word1/word2/g`：n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2
  - `:1,$s/word1/word2/g`：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 
  - `:1,$s/word1/word2/gc`：从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认是否需要取代

#####  进入插入或取代的编辑模式

- `i, I`：进入插入模式（Insert mode）
  - `i` 为“从目前光标所在处插入”， `I` 为“在目前所在列的第一个非空白字符处开始插入”
- `a, A`：进入插入模式（Insert mode）
  - `a` 为“从目前光标所在的下一个字符处开始插入”， `A` 为“从光标所在列的最后一个字符处开始插入”
- `o, O`：进入插入模式（Insert mode）
  - `o` 为“在目前光标所在的下一列处插入新的一列”，`O` 为在目前光标所在处的上一列插入新的一列
- `r, R`：进入取代模式（Replace mode）
  - r 只会取代光标所在的那一个字符一次，R会一直取代光标所在的文字，直到按下 ESC 为止
- `[Esc]`：退出编辑模式，回到一般指令模式中（常用）

##### 一般指令模式切换到指令列模式的可用按钮说明

- 指令列模式的储存、离开等指令
  - `:w`：将编辑的数据写入硬盘文件中
  - `:w!`：若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关
  - `:q`：离开 vi
  - `:q!`：若曾修改过文件，又不想储存，使用 `!` 为强制离开不储存
  - `:wq`：储存后离开，若为 `:wq!` 则为强制储存后离开
  - `ZZ`：若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开
  - `:w [filename]`：将编辑的数据储存成另一个文件（类似另存新文件）
  - `:r [filename]`：在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面
  - `:n1,n2 w [filename]`：将 n1 到 n2 的内容储存成 filename 这个文件
  - `:! command`：暂时离开 vi 到指令列模式下执行 command 的显示结果。例如 `:! ls /home` 即可在 vi 当中察看 `/home` 下面以 ls 输出的文件信息
- vim 环境的变更
  - `:set nu`：显示行号，设置之后，会在每一列的字首显示该列的行号
  - `:set nonu`：与 set nu 相反，为取消行号

##### 区块选择（Visual Block）

- `v`：字符选择，会将光标经过的地方反白选择
- `V`：列选择，会将光标经过的列反白选择
- `[Ctrl]+v`：区块选择，可以用长方形的方式选择数据
- `y`：将反白的地方复制起来
- `d`：将反白的地方删除掉
- `p`：将刚刚复制的区块，在光标所在处贴上

##### 多文件编辑

通过 `vim file1 file2` 指令来使用一个 vim 打开两个文件

- `:n`：编辑下一个文件
- `:N`：编辑上一个文件
- `:files`：列出目前这个 vim 的打开的所有文件

##### 多窗口功能

- `:sp [filename]`：打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）
- `[ctrl]+w+j` / `[ctrl]+w+↓` ：按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口
- `[ctrl]+w+k` / `[ctrl]+w+↑`：同上，不过光标移动到上面的窗口
- `[ctrl]+w+q`：其实就是 `:q` 结束离开。举例来说，如果我想要结束下方的窗口，那么利用 `[ctrl]+w+↓`移动到下方窗口后，按下 `:q` 即可离开， 也可以按下 `[ctrl]+w+q` 

### Bash

默认的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。
这么多的指令记录在哪里呢？在你的主文件夹内的 `.bash_history` 啦！ 不过，需要留意的是，`~/.bash_history` 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 `.bash_history` 当中

bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 `/etc/profile` 与 `~/.bash_profile`， non-login shell 则仅读取 `~/.bashrc`

##### 命令别名设置功能 alias

假如我们需要知道这个目录下面的所有文件 （包含隐藏文件） 及所有的文件属性，那么我就必须要下达 `ls -al` 这样的指令串。为了避免麻烦，可以使用命令别名。例如直接以`lm`这个自订的命令来取代上面的命令，也就是说， `lm` 会等于 `ls -al` 这样的一个功能

- 设置别名：`alias lm='ls -al'`
-  查看系统目前的别名有哪些：`alias`

##### 查询指令是否为 Bash shell 的内置命令 type

`type [-tpa] name` 选项与参数

- 不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
- `-t`：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义
  - `file`：表示为外部指令
  - `alias`：表示该指令为命令别名所设置的名称
  - `builtin`：表示该指令为 bash 内置的指令功能
- `-p`：如果后面接的 name 为外部指令时，才会显示完整文件名
- `-a`：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias

##### 万用字符

- `*`：代表“ 0 个到无穷多个”任意字符
- `?`：代表“一定有一个”任意字符
- `[ ]`：同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个“
- `[ - ]`：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的
- `[^ ]`：若中括号内的第一个字符为指数符号（`^`），那表示“反向选择”，例如 `[^abc]` 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思

##### 特殊字符

- `#` 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行
- `\` 跳脱符号：将“特殊字符或万用字符”还原成一般字符
- `|` 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；
- `;` 连续指令下达分隔符号：连续性命令的界定 （注意！与管线命令并不相同）
- `~` 使用者的主文件夹
- `$` 取用变量前置字符：亦即是变量之前需要加的变量取代值
- `&` 工作控制 （job control）：将指令变成背景下工作
- `!` 逻辑运算意义上的“非” not 的意思！
- `/` 目录符号：路径分隔的符号
- `>`, `>>` 数据流重导向：输出导向，分别是“取代”与“累加”
- `<`, `<<` 数据流重导向：输入导向 （这两个留待下节介绍）
- `' '` 单引号，不具有变量置换的功能（`$` 变为纯文本）
- `" "` 具有变量置换的功能！（`$` 可保留相关功能）
- ` ` 两个 ` 中间为可以先执行的指令，亦可使用 $（ ）
- `（ ）` 在中间为子 shell 的起始与结束
- `{ }` 在中间为命令区块的组合

### 正则表达式

##### 基础正则表达式字符汇整

- `^word`：待搜寻的字串（word）在行首！范例：搜寻行首为 # 开始的那一行，并列出行号
  -  `grep -n '^#' regular_express.txt`
- `word$`：待搜寻的字串（word）在行尾！范例：将行尾为 ! 的那一行打印出来，并列出行号
  -  `grep -n '!$' regular_express.txt`
- `.`：代表“一定有一个任意字符”的字符！范例：搜寻的字串可以是 （eve）（eae）（eee）（e e）， 但不能仅有 （ee） ！亦即 e 与 e 中间“一定”仅有一个字符，而空白字符也是字符
  - `grep -n 'e.e' regular_express.txt`
- `\`：跳脱字符，将特殊符号的特殊意义去除！范例：搜寻含有单引号 ' 的那一
  行
  - `grep -n \' regular_express.txt`
- `*`：重复零个到无穷多个的前一个 RE 字符 范例：找出含有 （es） （ess）
  （esss） 等等的字串，注意，因为 可以是 0 个，所以 es 也是符合带搜寻字
  串。另外，因为 为重复“前一个 RE 字符”的符号， 因此，在 之前必须要紧接着
  一个 RE 字符喔！例如任意字符则为 “.” ！
  - `grep -n 'ess*' regular_express.txt`
- `[list]`：字符集合的 RE 字符，里面列出想要撷取的字符！范例：搜寻含有
  （gl） 或 （gd） 的那一行，需要特别留意的是，在 [] 当中“谨代表一个待搜寻
  的字符”， 例如“ a[afl]y ”代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f
  或 l 的意思
  - `grep -n 'g[ld]' regular_express.txt`
- `[n1-n2]`：字符集合的 RE 字符，里面列出想要撷取的字符范围！范例：搜寻含有
  任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，
  他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，因
  此，你的编码需要设置正确（在 bash 当中，需要确定 LANG 与 LANGUAGE
  的变量是否正确！） 例如所有大写字符则为 [A-Z]
  - `grep -n '[A-Z]' regular_express.txt`
- `[^list]`：字符集合的 RE 字符，里面列出不要的字串或范围！范例：搜寻的字串
  可以是 （oog） （ood） 但不能是 （oot） ，那个 ^ 在 [] 内时，代表的意义
  是“反向选择”的意思。 例如，我不要大写字符，则为 [^A-Z]。但是，需要特别
  注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内
  的所有行都被列出，为什么？因为这个 [^A-Z] 是“非大写字符”的意思， 因为每
  一行均有非大写字符，例如第一行的 "Open Source" 就有 p,e,n,o.... 等等的小
  写字
  - `grep -n 'oo[^t]' regular_express.txt`
- `{n,m}`：连续 n 到 m 个的“前一个 RE 字符” 意义：若为 {n} 则是连续 n 个的前一
  个 RE 字符， 意义：若是 {n,} 则是连续 n 个以上的前一个 RE 字符！ 范例：在
  g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 （goog）（gooog）
  - `grep -n 'go\{2,3\}g' regular_express.txt`

### 系统服务

简单来说，系统为了某些功能必须要提供一些服务，这个服务就被成为`service`，而`daemon`指的是达成这个`service`的程序

##### System V init

早期`system V`的`init`管理机制特色

- 所有的服务启动管理脚本都放置在`/etc/init.d/`下面，通过以下方式来处理

  - 启动：`/etc/init.d/daemon start`
  - 关闭：`/etc/init.d/daemon stop`
  - 重新启动：`/etc/init.d/daemon restart`
  - 观察状态：`/etc/init.d/daemon status`

- 执行等级的分类：`init`可以依据使用者自订的使用等级（runlevel）来唤醒不同的服务，以进入不同的操作界面。Linux提供7个执行等级（0-6）

  - 0）：关机
  - 1）：单用户模式，只root进行维护
  - 2）：多用户，不能使用net file system
  - 3）：纯文本模式
  - 4）：安全模式
  - 5）：文字加图形界面
  - 6）：重启

  各个执行等级的启动脚本通过`/etc/rc.d/rc[0-6]/SXXdaemon`链接到`/etc/init.d/daemon`，链接文件名（SXXdaemon）的功能为：S为启动该服务，XX是数字，为启动顺序。如要创建如上提到的SXXdaemon，不需要管理员手动创建链接文件，通过如下指令来处理

  - 默认要启动：`chkconfig daemon on`
  - 默认不启动：`chkconfig daemon off`
  - 观察是否默认启动：`chkconfig --list daemon`

- 执行等级的切换行为： 当从纯命令行 （runlevel 3） 切换到图形界面 （runlevel
  5）， 不需要手动启动、关闭该执行等级的相关服务，只要`init 5`即可切换，`init`就会主动去分析`/etc/rc.d/rc[35].d/`这两个目录内的脚本， 然后启动转换runlevel中需要的
  服务，就完成整体的runlevel切换

#####  Systemd

Centos 7.x以及Ubuntu 16.04采用的`systemd`服务管理机制特色

- 平行处理所有服务：不同于旧的`init`启动脚本按序启动任务的模式，`systemd`可以让服务同时启动
- 仅通过`systemctl`指令来处理，无需其他额外指令的支持
- 以daemon功能分类：`systemd`将服务单位（unit）区分为service，socket，target，path
- `systemd`的配置文件放置目录

  - `/usr/lib/systemd/system/`：每个服务最主要的启动脚本设置，类似于以前的`/etc/init.d`下面的文件
  - `/run/systemd/system/`：系统执行过程中所产生的服务脚本，这些脚本的优先序要比`/usr/lib/systemd/system/`高
  - `/etc/systemd/system/`：管理员依据主机系统的需求所创建的执行脚本，执行优先序又比`/run/systemd/system/`高，该目录下放置的一般是链接文件，实际执行的是`/usr/lib/systemd/system/`下的脚本文件

###### Unit

``systemd`可以管理所有系统资源。不同的资源统称为Unit（单位），Unit一共分为12种

- `Service Unit`：系统服务
- `Target Unit`：多个 Unit 构成的一个组
- `Device Unit`：硬件设备
- `Mount Unit`：文件系统的挂载点
- `Automount Unit`：自动挂载点
- `Path Unit`：文件或路径
- `Scope Unit`：不是由 Systemd 启动的外部进程
- `Slice Unit`：进程组
- `Snapshot Unit`：Systemd 快照，可以切回某个快照
- `Socket Unit`：进程间通信的 socket
- `Swap Unit`：swap 文件
- `Timer Unit`：定时器

通过`systemctl list-units`命令可以查看当前系统所有的Unit，Unit之间存在依赖关系，如果A依赖于B，就意味着systemd在启动A的时候，同时会去启动B，可以通过`systemctl list-dependencies`命令列出一个Unit的所有依赖

Unit的配置文件：每一个Unit都有一个配置文件，告诉systemd如何启动这个Unit，systemd默认从`/etc/systemd/system/`读取配置文件，但该目录下，大部分文件都是链接文件，指向目录`/usr/lib/systemd/system/`，真正的配置文件都存放在那个目录，`systemctl enable`命令用于在上面两个目录之间建立服务链接关系

- 通过`systemctl list-unit-files`来列出所有配置文件
- Unit配置文件的完整字段清单，参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)

###### Target

启动系统时，需要启动大量的Unit，如果每一次启动都需要一一写明本次启动需要哪些Unit，显然非常不方便。`systemd`的解决方案就是`Target`。简单来说，`Target`就是一个Unit组，包含许多相关的Unit。启动某个Target时，systemd就会启动里面所有的Unit

##### Systemctl

通过`systemctl`指令管理服务：`systemctl [command] [unit]`，command主要有

- `start` ：立刻启动后面接的 unit
- `stop` ：立刻关闭后面接的 unit
- `restart` ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思
- `reload` ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效
- `enable` ：设置下次开机时，后面接的 unit 会被启动
- `disable` ：设置下次开机时，后面接的 unit 不会被启动
- `status` ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等
- `is-active` ：目前有没有正在运行中
- `is-enable` ：开机时有没有默认要启用这个 unit


