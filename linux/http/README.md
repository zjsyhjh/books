## HTTP基础知识

#### 1. HTTP报文

`HTTP`报文由一行一行的简单字符串组成。从`web`客户端发往`web`服务器的`HTTP`报文称为**请求报文**。从服务器发往客户端的报文成为**响应报文**。`HTTP`报文包括以下三个部分

- **起始行**：报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况
- **首部字段**：起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单
- **主体**：空行之后就是可选的主体了，其中包含了所有类型的数据。请求主体中包含了要发送给`web`服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、可执行程序等）

![http-get](https://github.com/zjsyhjh/reading/blob/master/linux/tcp-ip/efficient-web-server/png/get.png?raw=true)



#### 2. 连接、IP地址及端口号 

`HTTP`协议位于应用层，使用`TCP`来传输其报文数据。在`HTTP`客户端向服务器发送报文之前，需要使用网际协议（IP）地址和端口号在客户端和服务器之间建立一条`TCP/IP`连接。步骤如下

- 浏览器从`URL` 中解析出服务器的主机名，查询域名服务（`DNS`）器将主机名转换为服务器的`IP`地址
- 浏览器将端口号（如果有的话）从`URL`中解析出来
- 浏览器建立一条与`web`服务器的`TCP`连接
- 浏览器向服务器发送一条`HTTP`请求报文
- 服务器向浏览器回送一条`HTTP`响应报文
- 关闭连接，浏览器显示文档


#### 3. HTTP一些基本方法

- `GET`通常用于请求服务器发送某个资源
- `HEAD`方法与`GET`方法的行为很类似，但服务器在响应中只返回**首部**，不会返回实体的主体部分，使用`HEAD`，可以：
  - 在不获取资源的情况下了解资源的情况（比如判断其类型）
  - 通过查看响应中的状态码，看看某个对象是否存在
  - 通过查看首部，测试资源是否被修改了
- `PUT`方法会向服务器写入文档，该方法的语义就是让服务器用请求的主体部分来创建一个由所请求的`URL`命令的新文档，或者，如果那么`URL`已经存在，就用这个主体来替代它
- `POST`方法用于向服务器发送数据，通常会用它来支持`HTML`的表单，表单中填写的数据会被发送给服务器，然后由服务器将其发送到它要去的地方（比如送到一个服务器网关程序中，然后由这个程序对其进行处理）
- `TRACE`请求会在目的服务器端发起一个”环回“诊断。行程最后一站的服务器会弹回一条`TRACE`响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间`HTTP`应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过
- `DELETE`方法就是请服务器删除请求`URL`所指定的资源



#### 4. HTTP一些常见状态码

- **1xx**消息
- **2xx**成功
  - **200 OK**：请求已成功，请求所希望的响应头或数据体将随此响应返回
- **3xx**重定向
  - **301 Moved Permanently**：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一
  - **302 Moved Temporarily**：要求客户端执行临时重定向
- **4xx**客户端错误
  - **403 Forbidden**：请求被服务器拒绝
  - **404 Not Found**：请求失败，请求所希望得到的资源未被在服务器上发现
- **5xx**服务器端错误
  - **500 Internal Server Error**：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理
  - **503 Service Unavailable**：由于临时的服务器维护或者过载，服务器当前无法处理请求



#### 5. 连接管理 

`HTTP`建立在`TCP`连接之上，`HTTP`事务的延迟有以下几种原因

- 客户端首先需要根据`URI`确定`web` 服务器的`IP`地址和端口号。如果最近没有对`URI`中的主机名进行访问，通过`DNS`解析系统将`URI`中的主机名转换成一个`IP`地址可能需要花费数十秒的时间
- 接下来，客户端会向服务器发送一条`TCP`连接请求，并等待服务器回送一个请求接受应答。每条新的`TCP`连接都会有连接建立延时。这个值通常最多只有一两秒，但如果有数百个`HTTP`请求的话，这个值会快速地叠加上去
- 一旦连接建立起来，客户端就会通过新建立的TCP管道来发送`HTTP`请求。数据到达时，`web`服务器会从`TCP`连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间
- 然后，`web`服务器会回送`HTTP`响应，这也需要花费时间

和`TCP`相关的时延包括

- `TCP`连接建立握手
  - 建立一条新的`TCP`连接时，甚至是在发送任意数据之前，`TCP`软件之间会交换一系列`IP`分组，如果连接只用来传输少量数据，这些交换过程就会严重降低`HTTP`性能（小的`HTTP`事务可能会在`TCP`建立上花费50%，或更多的时间）
- `TCP`慢启动拥塞控制
  - `TCP`慢启动限制了一个`TCP`端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个`HTTP`事务有大量数据要发送，是不能一次将所有分组都发送出去的，必须发送一个分组，等待确认，然后可以发送两个分组，以此类推。这种方式被称为“打开拥塞窗口”。
- 数据聚集`Nagle`算法
  - `TCP`有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入`TCP`栈中（即使只有一个字节也可以）。但是每个`TCP`段中都至少装载了40个自己的标记和首部，所以如果`TCP`发送了大量包含少数数据的分组，网络的性能就会严重下降
  - `Nagle`算法试图在发送一个分组之前，将大量`TCP`数据绑定在一起，以提高网络效率
  - 应用程序常常会在自己的栈中设置参数`TCP_NODELAY`，禁用`Nagle`算法，提高性能
- 用于捎带确认的`TCP`延迟确认算法
  - `TCP`实现了自己的确认机制来确保数据的成功传输。每个`TCP`段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据
  - 由于确认报文很小，所以`TCP`允许在发往相同方向的输出数据分组中对其进行“捎带”。`TCP` 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多`TCP`栈都实现了一种“延迟确认”算法。“延迟确认”算法会在一个特定的时间窗口内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那段时间内没有输出数据分组，就将确认信息放在单独的分组发送
- `TIME_WAIT`时延和端口耗尽
  - `TIME_WAIT`端口耗尽是很严重的性能问题，会影响到性能基准。当某个`TCP` 端点关闭`TCP`连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的`IP`地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为2MSL）左右，以确保这段时间内不会创建具有相同地址和端口号的新连接



#### 6. HTTP连接的处理

几种可以提高`HTTP`连接性能的方法

- 并行连接：通过多条`TCP`连接发起并发的`HTTP`请求
- 持久连接：重用`TCP`连接，以消除连接及关闭时延
  - `HTTP/1.0+ keep-alive连接`：实现`HTTP/1.0 keep-alive`连接的客户端可以通过`Connection: Keep-Alive`首部请求将一条连接保持在打开状态。如果服务器愿意为下一条请求连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有`Connection: Keep-Alive`首部，客户端就认为服务器不支持`keep-alive`，会在发回响应报文之后关闭连接
  - `HTTP/1.1`持久连接：与`HTTP/1.0+`的`keep-alive`连接不同，`HTTP/1.1`持久连接在默认情况下是激活的。除非特别指明，否则`HTTP/1.1`假定所有连接都是持久的。要在事务处理结束之后将连接关闭，`HTTP/1.1`应用程序必须向报文中显示地添加一个`Connection: close`首部
- 管道化连接：通过共享的`TCP`连接发起并发的`HTTP`请求
  - `HTTP/1.1`允许在持久连接上可选地使用请求管道。这是在`keep-alive`连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器器时，第二条和第三条就可以开始发送了。在高延时网络条件下，这样做可以降低网络的环回时间，提高性能


#### 7. 使用Cookie的状态管理 

`HTTP`是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。`Cookie`技术通过在请求和响应报文中写入`Cookie`信息来控制客户端的状态

`Cookie`会根据从服务器端发送的响应报文内的一个叫做`Set-Cookie`的首部字段信息，通知客户端保存`Cookie`。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入`Cookie`值后发送出去。服务器端发现客户端发送过来的`Cookie`后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录（称为`Session`），最后得到之前的状态信息

